local width = love.graphics.getWidth()
local height = love.graphics.getHeight()
love.graphics.setDefaultFilter("nearest", "nearest")
local img = love.graphics.newImage("debug.png")

shader = love.graphics.newShader([[
    extern float depth;
    //varying vec4 vpos;
    
    #ifdef VERTEX
    vec4 position(mat4 transform_projection, vec4 vertex_position)
    {
        float z = vertex_position.z;
        vec4 vpos = transform_projection * vertex_position;
        vpos.z = z; // reinstate z as multiplication with tp matrix clears it
        
        return vpos;
    }
    #endif
    #ifdef PIXEL

    #endif
]])

local mesh = love.graphics.newMesh({
    {"VertexPosition", "float", 3},
    {"VertexTexCoord", "float",2}
}, {
    {0, 0, 0, 0,0},
    {0, 100, 0, 0,1},
    {100, 0, 0, 1,0},

    {0, 100, 0, 0,1},
    {100, 0, 0, 1,0},
    {100, 100, 0, 1,1},


    {50+0, 50+0, -2.1, 0,0},
    {50+0, 50+100, 0.9, 0,1},
    {50+100, 50+0, 0.9, 1,0},

    {50+0, 50+100, 0.9, 0,1},
    {50+100, 50+0, 0.9, 1,0},
    {50+100, 50+100, 0.9, 1,1},
}, "triangles")
mesh:setTexture(img)
 
depthBuffer = love.graphics.newCanvas(1000, 1000, { type = "2d", format = "depth16", readable = true })
renderTarget1 = love.graphics.newCanvas(1000, 1000, { type = "2d", format = "normal", readable = true })
 
function love.update()
    
end
 
function love.draw()
    -- console.draw()
    
    love.graphics.setCanvas({renderTarget1, depthstencil = depthBuffer })
    love.graphics.clear(0.4, 0.4, 1.0, 0.0)
    
    love.graphics.setShader(shader)
    -- shader:send("depth", 1.0)
    love.graphics.setDepthMode("less", true)
    love.graphics.draw(mesh)
    -- shader:send("depth", 0.5)
    
    -- love.graphics.draw(img, 10, 10, 0, 4, 4)
    
    -- shader:send("depth", 0.8)
    
    -- love.graphics.draw(img, 25, 25, 0, 4, 4)
    
    love.graphics.reset()
    
    love.graphics.draw(renderTarget1)
    -- love.graphics.draw(depthBuffer, 0, 0, 0, 0.1, 0.1)
end


-- local mesh = love.graphics.newMesh({
--     {"VertexPosition", "float", 3},
--     {"VertexTexCoord", "float", 2}
-- }, {
--     {0, 0, 0, 0,0},
--     {0, 100, 0, 0,1},
--     {100, 0, 0, 1,0},

--     {0, 100, 0, 0,1},
--     {100, 0, 0, 1,0},
--     {100, 100, 0, 1,1},


--     {50+0, 50+0, 1.0, 0,0},
--     {50+0, 50+100, 1.0, 0,1},
--     {50+100, 50+0, 1.0, 1,0},

--     {50+0, 50+100, 1.0, 0,1},
--     {50+100, 50+0, 1.0, 1,0},
--     {50+100, 50+100, 1.0, 1,1},
-- }, "triangles")
-- -- local mesh = love.graphics.newMesh({
-- --     {10, 10, 0},
-- --     {100, 10, 0},
-- --     {10, 100, 0},
-- -- })
-- mesh:setTexture(img)

-- local shd = love.graphics.newShader([[
--     #ifdef VERTEX
--     uniform float z;
--     vec4 position(mat4 transform, vec4 vertexPosition) {
        
--         vec4 pos = transform * vertexPosition;
        
--         return pos;
--     }
--     #endif

--     #ifdef PIXEL
--     uniform float z = 0;
--     vec4 effect(vec4 color, Image tex, vec2 texture_coords, vec2 screen_coords) {
        
--         return Texel(tex, texture_coords);
--     }
--     #endif
-- ]])


-- love.graphics.setDepthMode("less", true)
-- function love.draw()
--     love.graphics.setCanvas({ depth=true})
--     love.graphics.clear(0,0,0,0, true, true)
    
--     love.graphics.setShader(shd)
--     -- shd:send("z",0)
--     love.graphics.draw(mesh,0,0)

--     -- love.graphics.setShader(shd)
--     -- shd:send("z",0.5)
--     -- love.graphics.draw(mesh,50,50)

--     -- love.graphics.setShader(shd)
--     -- shd:send("z",1)
--     -- love.graphics.draw(mesh,100,100)
-- end

-- local ceillingPixelShader = [[
-- uniform float width;
-- uniform float height;
-- uniform Image img;
-- uniform float mya;
-- uniform float tilt;


-- float calculateZ(float y) {
--     return height/((height+tilt)-y);
-- }

-- vec4 effect(vec4 color, Image tex, vec2 texture_coords, vec2 screen_coords)
-- {
--     float fov = 1.04f;
--     float step = fov / width;
--     float angle = mya-(1.04f / 2.0f) + (screen_coords.x * step);
--     vec2 dir = vec2(cos(angle), sin(angle));

--     float z = calculateZ(screen_coords.y); 
--     float s = 1.0f - (z/10);
--     float ppx = 100 + dir.x * (z/cos(angle-mya));
--     float ppy = 100 + dir.y * (z/cos(angle-mya));
--     float u = ppx - int(ppx);
--     float v = ppy - int(ppy);

--     vec3 colour = Texel(img, vec2(1.0f-u,v)).rgb;
--     return vec4(colour*s, 1.0f);
-- }
-- ]]

-- local floorPixelShader = [[
-- struct thing { float x; float y;};

-- uniform float width;
-- uniform float height;
-- uniform Image img;
-- uniform float mya;
-- uniform float tilt;
-- uniform vec2 abc;

-- vec4 effect(vec4 color, Image tex, vec2 texture_coords, vec2 screen_coords)
-- {
--     float fov = 1.04f;
--     float step = fov / width;
--     float angle = mya-(1.04f / 2.0f) + (screen_coords.x * step);
--     vec2 dir = vec2(cos(angle), sin(angle));

--     float z = height/(screen_coords.y-(height+tilt));
--     float s = 1.0f - (z/10);
--     float ppx = 0 + dir.x * (z/cos(angle-mya));
--     float ppy = 0 + dir.y * (z/cos(angle-mya));
--     float ux = floor(ppx);
--     float uy = floor(ppy);
    
--     if (ux >= 0 && ux < 6 && uy >= 0 && uy < 4) {
                
--         float u = ppx - ux;
--         float v = ppy - uy;

--         vec3 colour = Texel(img, vec2(u,v)).rgb;
--         gl_FragDepth = 10.0f;
--         return vec4(colour*s, abc.x);
--     } else {
--         discard;
--     }
-- }
-- ]]

-- local ceillingShader = love.graphics.newShader(ceillingPixelShader)
-- local floorShader = love.graphics.newShader(floorPixelShader)
-- local angle = 0
-- local tilt = 0
-- local mouseSensitivity = 2.
-- love.mouse.setRelativeMode(true)

-- ceillingShader:send("width", width)
-- floorShader:send("width", width)
-- ceillingShader:send("height", height/2)
-- floorShader:send("height", height/2)

-- function love.mousemoved(x,y,dx,dy,istouch)
--     angle = angle + (dx * 0.001 * mouseSensitivity)
--     tilt = math.max(-height, math.min(height, tilt - dy * 1.5  ))
    
    
-- end

-- local tt = 0
-- local samples = 0

-- function love.keypressed(key)
--     if key == "escape" then
--         local avgT = (tt / samples) * 1000000
--         print(avgT .. "us/".. samples .. " samples")
--         love.event.quit()
--     end
-- end

-- function love.draw()
    
--     love.graphics.clear()
--     local start = love.timer.getTime()

--     love.graphics.setShader(ceillingShader)
--     ceillingShader:send("img", img)
--     ceillingShader:send("mya", angle)
--     ceillingShader:send("tilt", tilt)
--     love.graphics.rectangle("fill", 0,0, width,height/2 + tilt)

--     love.graphics.setShader(floorShader)
--     floorShader:send("img", img)
--     floorShader:send("mya", angle)
--     floorShader:send("tilt", tilt)
--     floorShader:send("abc", {1, 1})
--     love.graphics.rectangle("fill", 0,height/2+tilt, width,height/2-tilt)
    
--     love.graphics.setShader()
--     local t = love.timer.getTime() - start

--     -- love.graphics.setColor(0,0,0,1)
--     love.graphics.print(string.format("%.0fus",t*1000000 ),5,5)
--     -- print(t)
--     tt = tt + t
--     samples = samples + 1    





--     love.graphics.setColor(1,1,1,1)
-- end

